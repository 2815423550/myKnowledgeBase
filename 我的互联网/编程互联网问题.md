前端上传图片到后端？



还有一个问题那就是，怎么样在vue-element-admin的路由页面里添加html页面？或者说怎么把html页面转化成
vue页面？



其实吧，问题很少，你可以基于这个模板，去把填表预约的功能转到后端，然后html页面也放在idea里，这样开启
服务的话就不用每次都要手动去开启html的服务端口？







如何设置右键新建文件里的内容？？





@EqualsAndHashCode(callSuper = false)		这个注解什么意思





@Accessors(chain = true)		这个注解什么意思





mybatisplus的代码生成器生成的mapper跟老师写的这个mapper怎么不一样？？

![image-20221021201900765.png](https://s2.loli.net/2022/11/10/H3nJT2vUhOaMf4s.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itheima.reggie.dao.EmployeeMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="com.itheima.reggie.entity.Employee">
        <id column="id" property="id" />
        <result column="name" property="name" />
        <result column="username" property="username" />
        <result column="password" property="password" />
        <result column="phone" property="phone" />
        <result column="sex" property="sex" />
        <result column="id_number" property="id_number" />
        <result column="status" property="status" />
        <result column="create_time" property="create_time" />
        <result column="update_time" property="update_time" />
        <result column="create_user" property="create_user" />
        <result column="update_user" property="update_user" />
    </resultMap>

</mapper>
```



下面是老师写的mapper：
![image-20221021202059825.png](https://s2.loli.net/2022/11/10/QTJeHaOW9w1ozpy.png)

```java
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.itheima.reggie.entity.Employee;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface EmployeeMapper extends BaseMapper<Employee>{
}
```



而且，如果使用代码生成器的那个mapper的话执行会出现错误：

org.springframework.beans.factory.UnsatisfiedDependencyException

![image-20221021202317583](C:\Users\28154\AppData\Roaming\Typora\typora-user-images\image-20221021202317583.png)



使用老师的那个mapper



有一个问题，如果以后你开发完了一个很好的项目，但是你不想你的导师拿到你的源码，你又不得已提交项目的代码，那该怎么办，如何把代码变得完全没有注释以及把所有的代码变成一行，或者给代码进行编译成01010 ？？？（埋雷）





12.Swagger（有超大的问题!!! 插眼）

插眼留着什么时候做呢？我也不知道，反正现在没有心情做

一，Swagger是什么？

swagger用于开发中各种请求调用的测试，比如：虽然说get请求可以直接去浏览器进行访问来测试，但是如果是delect请求我们浏览器就无法进行测试，所以需要用到swagger这个工具来帮助我们进行测试





二、常用注解

- @ApiOperation()用于方法；

表示一个http请求的操作，例如：

```java
//2.逻辑删除医院设置
@ApiOperation(value = "逻辑删除医院设置")
@DeleteMapping("{id}")
public Result removeHospSet(@PathVariable Long id) {
   boolean flag = hospitalSetService.removeById(id);
   if (flag) {
      return Result.ok();
    } else {
       return Result.fail();
    }
}
```



- #### @ApiModelProperty()用于方法，字段

表示对model属性的说明或者数据操作更改

```java
@ApiModelProperty(value = "主键")
private Long id;

@ApiModelProperty(value = "姓名")
private String name;
```

###### 

三、使用方法

步骤1:pom文件导入依赖

```xml
<!--swagger-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.9.2</version>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>2.9.2</version>
        </dependency>
```



步骤2:启动类添加@EnableSwagger2注解

```java
@SpringBootApplication
@EnableSwagger2
public class ServiceGoodsApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceGoodsApplication.class);
    }
}
```



步骤3:编写SwaggerConfig文件（swagger的配置文件）

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@EnableSwagger2
@Configuration
//Profile是方法1（只在dev和test环境下开启）
@Profile({"dev","test"})
public class SwaggerConfig implements WebMvcConfigurer {
    //是否开启swagger，正式环境一般是需要关闭的，可根据springboot的多环境配置进行设置
    //这个是方法2哦，使用的话在new Docket里添加.Enable方法将参数放入即可
    @Value(value = "${swagger.show}")
    private Boolean swaggerEnabled;

    /**
    * apiInfo() 增加API相关信息
    * 所有的注解
    * .apis(RequestHandlerSelectors.any()) 
    * 指定部分注解1.Api.class(@APi),2.ApiOperation.class(@ApiOperation),3.ApiImplicitParam.class(@ApiImplicitParam)
    *.apis(RequestHandlerSelectors.withMethodAnnotation(Api.class))
    * 指定包路径
    * .apis(RequestHandlerSelectors.basePackage("这里填写需要的路径"))
    * .paths() 这个是包路径下的路径,PathSelectors.any()是包下所有路径
    */
    @Bean
    public Docket createRestApi() {
        log.info(""+swaggerEnabled);
        return new Docket(DocumentationType.SWAGGER_2)
                .useDefaultResponseMessages(false)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.any())
                .paths(PathSelectors.any())
                //创建
                .build();
    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("SpringBoot-Swagger2集成")
                .description("springboot | swagger")
                // 作者信息
                .contact(new Contact("kacen", "https://www.xxxx.com", "abc@qq.com"))
                .version("0.0.1")
                .build();
    }

    //这个是可要可不要的，具体看需求
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/js/**").addResourceLocations("classpath:/js/");
        registry.addResourceHandler("swagger-ui.html")
                .addResourceLocations("classpath:/META-INF/resources/");
        registry.addResourceHandler("/webjars/**")
                .addResourceLocations("classpath:/META-INF/resources/webjars/");
    }

}
```

然后访问：<u>http://服务器ip:端口/swagger-ui.html#/</u>   来查看结果



------















5.springMVC

SpringMVC 是 Spring 为表述层（或表现层）开发提供的一整套完备的解决方案。

也就是说，在java项目里，表现层采用MVC模式。



什么是MVC？

MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分

M：Model，模型层，指工程中的JavaBean，作用是处理数据

JavaBean分为两类：

- 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等
- 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。

V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据

C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器

MVC的工作流程：
用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器



@RequestMapping

**功能：**

@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。

SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。



**位置：**

@RequestMapping标识一个类：设置映射请求的请求路径的初始信息

@RequestMapping标识一个方法：设置映射请求请求路径的具体信息





**属性：**value、method、params

```java
@Controller
@RequestMapping("/test")
public class RequestMappingController {

	//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping 或者 /test/test
    //若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions "username, password!=123456" not met for actual request parameters: username={admin}, password={123456}
    @RequestMapping(
        value = {"/testRequestMapping", "/test"},
        method = {RequestMethod.GET, RequestMethod.POST},
        params = {"username","password!=123456"}
    )
    public String testRequestMapping(){
        return "success";
    }

}
```

对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解

处理get请求的映射-->@GetMapping

处理post请求的映射-->@PostMapping

处理put请求的映射-->@PutMapping

处理delete请求的映射-->@DeleteMapping







6.Mybatis

他是持久层框架

















































































































































